// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, async, dgram, http, makeUuid, os, ssdp, url, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  dgram = require('dgram');

  makeUuid = require('node-uuid');

  url = require('url');

  os = require('os');

  async = require('async');

  _ = require("underscore");

  http = require("http");

  EventEmitter = require('events').EventEmitter;

  ssdp = (function(_super) {
    __extends(ssdp, _super);

    ssdp.prototype.address = '239.255.255.250';

    ssdp.prototype.port = 1900;

    ssdp.prototype.timeout = 1800;

    ssdp.prototype.ttl = 4;

    ssdp.prototype.uuid = makeUuid();

    ssdp.prototype.name = "Upnp-Device-Host";

    function ssdp() {
      var _this = this;
      this.broadcastSocket = dgram.createSocket('udp4', this.ssdpListener);
      this.broadcastSocket.bind(this.port, '0.0.0.0', function() {
        _this.broadcastSocket.addMembership(_this.address);
        _this.broadcastSocket.setMulticastTTL(_this.ttl);
        return _this.emit('ready');
      });
    }

    ssdp.prototype.announce = function(device) {
      this.multicast('byebye', device);
      return this.multicast('alive', device);
    };

    ssdp.prototype.ssdpListener = function() {
      var answer, respondTo,
        _this = this;
      answer = function(address, port) {
        var st;
        return _this.ssdpSend((function() {
          var _i, _len, _ref, _results;
          _ref = this.makeNotificationTypes();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            st = _ref[_i];
            _results.push(this.makeSsdpMessage('ok', {
              st: st,
              ext: null
            }));
          }
          return _results;
        }).call(_this), address, port);
      };
      respondTo = ['ssdp:all', 'upnp:rootdevice', this.makeType(), this.uuid];
      return this.parseRequest(msg, rinfo, function(err, req) {
        var wait, _ref;
        if (req.method === 'M-SEARCH' && (_ref = req.st, __indexOf.call(respondTo, _ref) >= 0)) {
          wait = Math.floor(Math.random() * (parseInt(maxWait)) * 1000);
          return setTimeout(answer, req.mx, req.address, req.port);
        }
      });
    };

    ssdp.prototype.parseRequest = function(msg, rinfo, cb) {
      var parser;
      parser = http.parsers.alloc();
      parser.reinitialize('request');
      parser.socket = {};
      parser.onIncoming = function(req) {
        var address, method, mx, nt, nts, port, st, usn, _ref;
        http.parsers.free(parser);
        method = req.method, (_ref = req.headers, mx = _ref.mx, st = _ref.st, nt = _ref.nt, nts = _ref.nts, usn = _ref.usn);
        address = rinfo.address, port = rinfo.port;
        return cb(null, {
          method: method,
          mx: mx,
          st: st,
          nt: nt,
          nts: nts,
          usn: usn,
          address: address,
          port: port
        });
      };
      return parser.execute(msg, 0, msg.length);
    };

    ssdp.prototype.makeHttpMessage = function(reqType, headers) {
      var h, message, v;
      message = reqType === 'ok' ? ["HTTP/1.1 200 OK"] : ["" + (reqType.toUpperCase()) + " * HTTP/1.1"];
      for (h in headers) {
        v = headers[h];
        message.push("" + (h.toUpperCase()) + ": " + v);
      }
      message.push('\r\n');
      return new Buffer(message.join('\r\n'));
    };

    ssdp.prototype.makeSsdpMessage = function(reqType, customHeaders) {
      var header, headers, _i, _len, _ref;
      _ref = ['cache-control', 'server', 'usn', 'location'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        header = _ref[_i];
        delete customHeaders[header];
      }
      headers = this.makeHeaders(customHeaders);
      return this.makeHttpMessage(reqType, headers);
    };

    ssdp.prototype.makeUrl = function(pathname) {
      var _ref;
      return url.format({
        protocol: 'http',
        hostname: (_ref = this.address) != null ? _ref : this.device.address,
        port: 999,
        pathname: pathname
      });
    };

    ssdp.prototype.makeHeaders = function(customHeaders) {
      var defaultHeaders, header, headers;
      defaultHeaders = {
        'cache-control': "max-age=" + this.timeout,
        'content-type': 'text/xml; charset="utf-8"',
        ext: '',
        host: "" + this.address + ":" + this.port,
        location: this.makeUrl('/device/description'),
        server: ["" + (os.type()) + "/" + (os.release()), "UPnP/1.0", "" + this.name + "/1.0"].join(' '),
        usn: ("uuid:" + this.uuid) + (("uuid:" + this.uuid) === (customHeaders.nt || customHeaders.st) ? '' : '::' + (customHeaders.nt || customHeaders.st))
      };
      customHeaders = _.extend(defaultHeaders, customHeaders);
      headers = {};
      for (header in customHeaders) {
        headers[header.toUpperCase()] = customHeaders[header];
      }
      return headers;
    };

    ssdp.prototype.ssdpMessages = async.queue(function(task, queueCb) {
      var address, messages, port, socket;
      messages = task.messages, address = task.address, port = task.port;
      socket = dgram.createSocket('udp4');
      socket.bind();
      return async.forEach(messages, function(msg, cb) {
        return socket.send(msg, 0, msg.length, port, address, cb);
      }, function(err) {
        if (err != null) {
          console.log(err);
        }
        socket.close();
        return queueCb();
      });
    });

    ssdp.prototype.makeType = function(entity, isService) {
      var _ref, _ref1;
      return ['urn', (_ref = entity.domain) != null ? _ref : 'schemas-upnp-org', isService ? 'service' : 'device', entity.name, (_ref1 = entity.version) != null ? _ref1 : 1].join(':');
    };

    ssdp.prototype.multicast = function(status, device) {
      var messages, nt, nts, service, services, _ref,
        _this = this;
      services = (_ref = device.services) != null ? _ref : [];
      console.log(services);
      console.log(device);
      nts = ['upnp:rootdevice', "uuid:" + this.uuid, this.makeType(device)].concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = services.length; _i < _len; _i++) {
          service = services[_i];
          _results.push(this.makeType(service, true));
        }
        return _results;
      }).call(this));
      messages = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = nts.length; _i < _len; _i++) {
          nt = nts[_i];
          _results.push(this.makeSsdpMessage("notify", {
            nt: nt,
            nts: "ssdp:" + status
          }));
        }
        return _results;
      }).call(this);
      return async.forEach(messages, function(msg, cb) {
        return _this.broadcastSocket.send(msg, 0, msg.length, _this.port, _this.address, cb);
      }, function(err) {
        if (err != null) {
          return console.log(err);
        }
      });
    };

    return ssdp;

  })(EventEmitter);

  module.exports = ssdp;

}).call(this);

/*
//@ sourceMappingURL=ssdp.map
*/
